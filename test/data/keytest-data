Flat profile:

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 25.58      0.56     0.56  3342029     0.00     0.00  vli_mult
 21.01      1.02     0.46 23303637     0.00     0.00  vli_sub
 18.95      1.44     0.42 22333354     0.00     0.00  vli_add
 10.50      1.67     0.23  1698291     0.00     0.00  vli_square
  7.08      1.82     0.16 10080640     0.00     0.00  vli_lshift
  6.39      1.96     0.14  5040320     0.00     0.00  vli_mmod_fast
  2.74      2.02     0.06  7294711     0.00     0.00  vli_set
  1.60      2.06     0.04  5227249     0.00     0.00  vli_cmp
  1.37      2.09     0.03     3600     0.01     0.01  ecc_native2bytes
  0.91      2.11     0.02  3342029     0.00     0.00  vli_modMult_fast
  0.91      2.13     0.02  1698291     0.00     0.00  vli_modSquare_fast
  0.91      2.15     0.02   270105     0.00     0.01  EccPoint_add_jacobian
  0.91      2.17     0.02   180117     0.00     0.00  EccPoint_double_jacobian
  0.91      2.19     0.02      709     0.03     3.00  EccPoint_mult
  0.23      2.19     0.01   810760     0.00     0.00  vli_modAdd
  0.00      2.19     0.00  2341402     0.00     0.00  vli_modSub
  0.00      2.19     0.00   901455     0.00     0.00  vli_isZero
  0.00      2.19     0.00   257333     0.00     0.00  vli_testBit
  0.00      2.19     0.00   180117     0.00     0.00  vli_rshift1
  0.00      2.19     0.00    89988     0.00     0.00  apply_z
  0.00      2.19     0.00     3704     0.00     0.00  ecc_bytes2native
  0.00      2.19     0.00     3300     0.00     0.00  vli_xor
  0.00      2.19     0.00     1013     0.00     0.00  vli_numBits
  0.00      2.19     0.00     1013     0.00     0.00  vli_numDigits
  0.00      2.19     0.00      405     0.00     0.00  getRandomNumber
  0.00      2.19     0.00      304     0.00     0.11  ecc_point_decompress
  0.00      2.19     0.00      304     0.00     0.11  mod_sqrt
  0.00      2.19     0.00      201     0.00     0.00  EccPoint_isZero
  0.00      2.19     0.00      100     0.00     3.38  ecc_decrypt
  0.00      2.19     0.00      100     0.00    12.48  ecc_encrypt
  0.00      2.19     0.00      100     0.00     6.05  ecc_make_key
  0.00      2.19     0.00      100     0.00     3.38  test_decrypt
  0.00      2.19     0.00      100     0.00    12.48  test_encrypt
  0.00      2.19     0.00      100     0.00     6.05  test_make_key

			Call graph


granularity: each sample hit covers 2 byte(s) for 0.46% of 2.19 seconds

index % time    self  children    called     name
                                                 <spontaneous>
[1]    100.0    0.00    2.19                 main [1]
                0.00    1.25     100/100         test_encrypt [6]
                0.00    0.60     100/100         test_make_key [11]
                0.00    0.34     100/100         test_decrypt [16]
-----------------------------------------------
                0.00    0.30     100/709         ecc_decrypt [15]
                0.01    0.60     201/709         ecc_make_key [10]
                0.01    1.21     408/709         ecc_encrypt [5]
[2]     97.1    0.02    2.11     709         EccPoint_mult [2]
                0.02    1.93  270105/270105      EccPoint_add_jacobian [3]
                0.00    0.14   89988/89988       apply_z [19]
                0.01    0.00 1173385/7294711     vli_set [20]
                0.00    0.00  180117/257333      vli_testBit [28]
                0.00    0.00     709/1013        vli_numBits [32]
-----------------------------------------------
                0.02    1.93  270105/270105      EccPoint_mult [2]
[3]     89.2    0.02    1.93  270105         EccPoint_add_jacobian [3]
                0.01    0.86 2160840/3342029     vli_modMult_fast [4]
                0.02    0.68  180117/180117      EccPoint_double_jacobian [8]
                0.01    0.30  810315/1698291     vli_modSquare_fast [9]
                0.00    0.04 1620630/2341402     vli_modSub [21]
                0.00    0.01  270105/810760      vli_modAdd [26]
                0.00    0.00  540351/7294711     vli_set [20]
                0.00    0.00  720327/901455      vli_isZero [27]
-----------------------------------------------
                0.00    0.00     304/3342029     ecc_point_decompress [23]
                0.00    0.00   10336/3342029     mod_sqrt [24]
                0.00    0.11  269964/3342029     apply_z [19]
                0.01    0.36  900585/3342029     EccPoint_double_jacobian [8]
                0.01    0.86 2160840/3342029     EccPoint_add_jacobian [3]
[4]     61.9    0.02    1.34 3342029         vli_modMult_fast [4]
                0.09    0.68 3342029/5040320     vli_mmod_fast [7]
                0.56    0.00 3342029/3342029     vli_mult [12]
-----------------------------------------------
                0.00    1.25     100/100         test_encrypt [6]
[5]     57.0    0.00    1.25     100         ecc_encrypt [5]
                0.01    1.21     408/709         EccPoint_mult [2]
                0.00    0.02     204/304         ecc_point_decompress [23]
                0.00    0.00     200/3600        ecc_native2bytes [25]
                0.00    0.00     204/5227249     vli_cmp [22]
                0.00    0.00     508/901455      vli_isZero [27]
                0.00    0.00     204/405         getRandomNumber [34]
                0.00    0.00     100/3704        ecc_bytes2native [30]
                0.00    0.00     100/3300        vli_xor [31]
-----------------------------------------------
                0.00    1.25     100/100         main [1]
[6]     57.0    0.00    1.25     100         test_encrypt [6]
                0.00    1.25     100/100         ecc_encrypt [5]
-----------------------------------------------
                0.05    0.35 1698291/5040320     vli_modSquare_fast [9]
                0.09    0.68 3342029/5040320     vli_modMult_fast [4]
[7]     53.4    0.14    1.03 5040320         vli_mmod_fast [7]
                0.41    0.00 20808676/23303637     vli_sub [13]
                0.39    0.00 21098093/22333354     vli_add [14]
                0.16    0.00 10080640/10080640     vli_lshift [18]
                0.04    0.00 5040320/7294711     vli_set [20]
                0.03    0.00 4569643/5227249     vli_cmp [22]
-----------------------------------------------
                0.02    0.68  180117/180117      EccPoint_add_jacobian [3]
[8]     31.9    0.02    0.68  180117         EccPoint_double_jacobian [8]
                0.01    0.36  900585/3342029     vli_modMult_fast [4]
                0.01    0.26  720468/1698291     vli_modSquare_fast [9]
                0.00    0.01  540351/810760      vli_modAdd [26]
                0.00    0.02  720468/2341402     vli_modSub [21]
                0.00    0.00  540351/7294711     vli_set [20]
                0.00    0.00  180117/901455      vli_isZero [27]
                0.00    0.00  180117/180117      vli_rshift1 [29]
-----------------------------------------------
                0.00    0.00     304/1698291     ecc_point_decompress [23]
                0.00    0.03   77216/1698291     mod_sqrt [24]
                0.00    0.03   89988/1698291     apply_z [19]
                0.01    0.26  720468/1698291     EccPoint_double_jacobian [8]
                0.01    0.30  810315/1698291     EccPoint_add_jacobian [3]
[9]     29.4    0.02    0.62 1698291         vli_modSquare_fast [9]
                0.05    0.35 1698291/5040320     vli_mmod_fast [7]
                0.23    0.00 1698291/1698291     vli_square [17]
-----------------------------------------------
                0.00    0.60     100/100         test_make_key [11]
[10]    27.6    0.00    0.60     100         ecc_make_key [10]
                0.01    0.60     201/709         EccPoint_mult [2]
                0.00    0.00     200/3600        ecc_native2bytes [25]
                0.00    0.00     201/5227249     vli_cmp [22]
                0.00    0.00     201/405         getRandomNumber [34]
                0.00    0.00     201/901455      vli_isZero [27]
                0.00    0.00     201/201         EccPoint_isZero [35]
-----------------------------------------------
                0.00    0.60     100/100         main [1]
[11]    27.6    0.00    0.60     100         test_make_key [11]
                0.00    0.60     100/100         ecc_make_key [10]
-----------------------------------------------
                0.56    0.00 3342029/3342029     vli_modMult_fast [4]
[12]    25.6    0.56    0.00 3342029         vli_mult [12]
-----------------------------------------------
                0.00    0.00  153559/23303637     vli_modAdd [26]
                0.05    0.00 2341402/23303637     vli_modSub [21]
                0.41    0.00 20808676/23303637     vli_mmod_fast [7]
[13]    21.0    0.46    0.00 23303637         vli_sub [13]
-----------------------------------------------
                0.00    0.00     304/22333354     mod_sqrt [24]
                0.01    0.00  424197/22333354     vli_modSub [21]
                0.02    0.00  810760/22333354     vli_modAdd [26]
                0.39    0.00 21098093/22333354     vli_mmod_fast [7]
[14]    18.9    0.42    0.00 22333354         vli_add [14]
-----------------------------------------------
                0.00    0.34     100/100         test_decrypt [16]
[15]    15.4    0.00    0.34     100         ecc_decrypt [15]
                0.00    0.30     100/709         EccPoint_mult [2]
                0.03    0.00    3200/3600        ecc_native2bytes [25]
                0.00    0.01     100/304         ecc_point_decompress [23]
                0.00    0.00    3300/3704        ecc_bytes2native [30]
                0.00    0.00    3200/3300        vli_xor [31]
-----------------------------------------------
                0.00    0.34     100/100         main [1]
[16]    15.4    0.00    0.34     100         test_decrypt [16]
                0.00    0.34     100/100         ecc_decrypt [15]
-----------------------------------------------
                0.23    0.00 1698291/1698291     vli_modSquare_fast [9]
[17]    10.5    0.23    0.00 1698291         vli_square [17]
-----------------------------------------------
                0.16    0.00 10080640/10080640     vli_mmod_fast [7]
[18]     7.1    0.16    0.00 10080640         vli_lshift [18]
-----------------------------------------------
                0.00    0.14   89988/89988       EccPoint_mult [2]
[19]     6.6    0.00    0.14   89988         apply_z [19]
                0.00    0.11  269964/3342029     vli_modMult_fast [4]
                0.00    0.03   89988/1698291     vli_modSquare_fast [9]
-----------------------------------------------
                0.00    0.00     304/7294711     mod_sqrt [24]
                0.00    0.00  540351/7294711     EccPoint_add_jacobian [3]
                0.00    0.00  540351/7294711     EccPoint_double_jacobian [8]
                0.01    0.00 1173385/7294711     EccPoint_mult [2]
                0.04    0.00 5040320/7294711     vli_mmod_fast [7]
[20]     2.7    0.06    0.00 7294711         vli_set [20]
-----------------------------------------------
                0.00    0.00     304/2341402     ecc_point_decompress [23]
                0.00    0.02  720468/2341402     EccPoint_double_jacobian [8]
                0.00    0.04 1620630/2341402     EccPoint_add_jacobian [3]
[21]     2.5    0.00    0.05 2341402         vli_modSub [21]
                0.05    0.00 2341402/23303637     vli_sub [13]
                0.01    0.00  424197/22333354     vli_add [14]
-----------------------------------------------
                0.00    0.00     201/5227249     ecc_make_key [10]
                0.00    0.00     204/5227249     ecc_encrypt [5]
                0.00    0.00  657201/5227249     vli_modAdd [26]
                0.03    0.00 4569643/5227249     vli_mmod_fast [7]
[22]     1.6    0.04    0.00 5227249         vli_cmp [22]
-----------------------------------------------
                0.00    0.01     100/304         ecc_decrypt [15]
                0.00    0.02     204/304         ecc_encrypt [5]
[23]     1.5    0.00    0.03     304         ecc_point_decompress [23]
                0.00    0.03     304/304         mod_sqrt [24]
                0.00    0.00     304/3342029     vli_modMult_fast [4]
                0.00    0.00     304/1698291     vli_modSquare_fast [9]
                0.00    0.00     304/810760      vli_modAdd [26]
                0.00    0.00     304/2341402     vli_modSub [21]
                0.00    0.00     304/3704        ecc_bytes2native [30]
-----------------------------------------------
                0.00    0.03     304/304         ecc_point_decompress [23]
[24]     1.5    0.00    0.03     304         mod_sqrt [24]
                0.00    0.03   77216/1698291     vli_modSquare_fast [9]
                0.00    0.00   10336/3342029     vli_modMult_fast [4]
                0.00    0.00     304/22333354     vli_add [14]
                0.00    0.00     304/7294711     vli_set [20]
                0.00    0.00   77216/257333      vli_testBit [28]
                0.00    0.00     304/1013        vli_numBits [32]
-----------------------------------------------
                0.00    0.00     200/3600        ecc_encrypt [5]
                0.00    0.00     200/3600        ecc_make_key [10]
                0.03    0.00    3200/3600        ecc_decrypt [15]
[25]     1.4    0.03    0.00    3600         ecc_native2bytes [25]
-----------------------------------------------
                0.00    0.00     304/810760      ecc_point_decompress [23]
                0.00    0.01  270105/810760      EccPoint_add_jacobian [3]
                0.00    0.01  540351/810760      EccPoint_double_jacobian [8]
[26]     1.3    0.01    0.02  810760         vli_modAdd [26]
                0.02    0.00  810760/22333354     vli_add [14]
                0.00    0.00  657201/5227249     vli_cmp [22]
                0.00    0.00  153559/23303637     vli_sub [13]
-----------------------------------------------
                0.00    0.00     201/901455      ecc_make_key [10]
                0.00    0.00     302/901455      EccPoint_isZero [35]
                0.00    0.00     508/901455      ecc_encrypt [5]
                0.00    0.00  180117/901455      EccPoint_double_jacobian [8]
                0.00    0.00  720327/901455      EccPoint_add_jacobian [3]
[27]     0.0    0.00    0.00  901455         vli_isZero [27]
-----------------------------------------------
                0.00    0.00   77216/257333      mod_sqrt [24]
                0.00    0.00  180117/257333      EccPoint_mult [2]
[28]     0.0    0.00    0.00  257333         vli_testBit [28]
-----------------------------------------------
                0.00    0.00  180117/180117      EccPoint_double_jacobian [8]
[29]     0.0    0.00    0.00  180117         vli_rshift1 [29]
-----------------------------------------------
                0.00    0.00     100/3704        ecc_encrypt [5]
                0.00    0.00     304/3704        ecc_point_decompress [23]
                0.00    0.00    3300/3704        ecc_decrypt [15]
[30]     0.0    0.00    0.00    3704         ecc_bytes2native [30]
-----------------------------------------------
                0.00    0.00     100/3300        ecc_encrypt [5]
                0.00    0.00    3200/3300        ecc_decrypt [15]
[31]     0.0    0.00    0.00    3300         vli_xor [31]
-----------------------------------------------
                0.00    0.00     304/1013        mod_sqrt [24]
                0.00    0.00     709/1013        EccPoint_mult [2]
[32]     0.0    0.00    0.00    1013         vli_numBits [32]
                0.00    0.00    1013/1013        vli_numDigits [33]
-----------------------------------------------
                0.00    0.00    1013/1013        vli_numBits [32]
[33]     0.0    0.00    0.00    1013         vli_numDigits [33]
-----------------------------------------------
                0.00    0.00     201/405         ecc_make_key [10]
                0.00    0.00     204/405         ecc_encrypt [5]
[34]     0.0    0.00    0.00     405         getRandomNumber [34]
-----------------------------------------------
                0.00    0.00     201/201         ecc_make_key [10]
[35]     0.0    0.00    0.00     201         EccPoint_isZero [35]
                0.00    0.00     302/901455      vli_isZero [27]
-----------------------------------------------

Index by function name

   [3] EccPoint_add_jacobian  [24] mod_sqrt               [21] vli_modSub
   [8] EccPoint_double_jacobian [16] test_decrypt         [12] vli_mult
  [35] EccPoint_isZero         [6] test_encrypt           [32] vli_numBits
   [2] EccPoint_mult          [11] test_make_key          [33] vli_numDigits
  [19] apply_z                [14] vli_add                [29] vli_rshift1
  [30] ecc_bytes2native       [22] vli_cmp                [20] vli_set
  [15] ecc_decrypt            [27] vli_isZero             [17] vli_square
   [5] ecc_encrypt            [18] vli_lshift             [13] vli_sub
  [10] ecc_make_key            [7] vli_mmod_fast          [28] vli_testBit
  [25] ecc_native2bytes       [26] vli_modAdd             [31] vli_xor
  [23] ecc_point_decompress    [4] vli_modMult_fast
  [34] getRandomNumber         [9] vli_modSquare_fast

*** File /home/wrk/workspace/easy-ecc/src/field/field_rand.c:
                #include <curves.h>
                #include <field.h>
                
                /* 
                    operations on numbers and vectors
                 */
                
                #if (defined(_WIN32) || defined(_WIN64))
                /* Windows */
                
                #define WIN32_LEAN_AND_MEAN
                #include <windows.h>
                #include <wincrypt.h>
                
                int getRandomNumber(uint64_t *p_vli)
                {
                    HCRYPTPROV l_prov;
                    if(!CryptAcquireContext(&l_prov, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
                    {
                        return 0;
                    }
                
                    CryptGenRandom(l_prov, ECC_BYTES, (BYTE *)p_vli);
                    CryptReleaseContext(l_prov, 0);
                    
                    return 1;
                }
                
                #else /* _WIN32 */
                
                /* Assume that we are using a POSIX-like system with /dev/urandom or /dev/random. */
                #include <sys/types.h>
                #include <fcntl.h>
                #include <unistd.h>
                
                #ifndef O_CLOEXEC
                    #define O_CLOEXEC 0
                #endif
                
                int getRandomNumber(uint64_t *p_vli)
         405 -> {
                    int l_fd = open("/dev/urandom", O_RDONLY | O_CLOEXEC);
                    if(l_fd == -1)
                    {
                        l_fd = open("/dev/random", O_RDONLY | O_CLOEXEC);
                        if(l_fd == -1)
                        {
                            return 0;
                        }
                    }
                    
                    char *l_ptr = (char *)p_vli;
                    size_t l_left = ECC_BYTES;
                    while(l_left > 0)
                    {
                        int l_read = read(l_fd, l_ptr, l_left);
                        if(l_read <= 0)
                        { // read failed
                            close(l_fd);
                            return 0;
                        }
                        l_left -= l_read;
                        l_ptr += l_read;
                    }
                    
                    close(l_fd);
                    return 1;
                }
                
                #endif /* _WIN32 */
                


Top 10 Lines:

     Line      Count

       41        405

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      405   Total number of line executions
   405.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/field/field_sqr.c:
                #include <curves.h>
                #include <field.h>
                
                #if SUPPORTS_INT128
                
                /* Computes p_result = p_left^2. */
                void vli_square(uint64_t *p_result, uint64_t *p_left)
     1698291 -> {
                    uint128_t r01 = 0;
                    uint64_t r2 = 0;
                    
                    uint i, k;
                    for(k=0; k < NUM_ECC_DIGITS*2 - 1; ++k)
                    {
                        uint l_min = (k < NUM_ECC_DIGITS ? 0 : (k + 1) - NUM_ECC_DIGITS);
                        for(i=l_min; i<=k && i<=k-i; ++i)
                        {
                            uint128_t l_product = (uint128_t)p_left[i] * p_left[k-i];
                            if(i < k-i)
                            {
                                r2 += l_product >> 127;
                                l_product *= 2;
                            }
                            r01 += l_product;
                            r2 += (r01 < l_product);
                        }
                        p_result[k] = (uint64_t)r01;
                        r01 = (r01 >> 64) | (((uint128_t)r2) << 64);
                        r2 = 0;
                    }
                    
                    p_result[NUM_ECC_DIGITS*2 - 1] = (uint64_t)r01;
                }
                
                #else /* #if SUPPORTS_INT128 */
                
                void vli_square(uint64_t *p_result, uint64_t *p_left)
                {
                    uint128_t r01 = {0, 0};
                    uint64_t r2 = 0;
                    
                    uint i, k;
                    for(k=0; k < NUM_ECC_DIGITS*2 - 1; ++k)
                    {
                        uint l_min = (k < NUM_ECC_DIGITS ? 0 : (k + 1) - NUM_ECC_DIGITS);
                        for(i=l_min; i<=k && i<=k-i; ++i)
                        {
                            uint128_t l_product = mul_64_64(p_left[i], p_left[k-i]);
                            if(i < k-i)
                            {
                                /*
                                    shift to the left with a bit means double the product, 
                                    the difference between this and the normal multiplication 
                                    is that the multiplication of the ith bit and the (k-i)th 
                                    bit is the same as the one of the (k-i)th bit and the ith 
                                    bit
                                 */
                                r2 += l_product.m_high >> 63;
                                l_product.m_high = (l_product.m_high << 1) | (l_product.m_low >> 63);
                                l_product.m_low <<= 1;
                            }
                            r01 = add_128_128(r01, l_product);
                            r2 += (r01.m_high < l_product.m_high);
                        }
                        p_result[k] = r01.m_low;
                        r01.m_low = r01.m_high;
                        r01.m_high = r2;
                        r2 = 0;
                    }
                    
                    p_result[NUM_ECC_DIGITS*2 - 1] = r01.m_low;
                }
                
                #endif /* SUPPORTS_INT128 */
                
                /* Computes p_result = p_left^2 % curve_p. */
                void vli_modSquare_fast(uint64_t *p_result, uint64_t *p_left)
     1698291 -> {
                    uint64_t l_product[2 * NUM_ECC_DIGITS];
                    vli_square(l_product, p_left);
                    vli_mmod_fast(p_result, l_product);
                }


Top 10 Lines:

     Line      Count

        8    1698291
       78    1698291

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

  3396582   Total number of line executions
1698291.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/ecc/ecc_decrypt.c:
                /** !
                 * @file ecc_opt.c
                 * @author Wang Ruikai 
                 * @date July 15th, 2019
                 * @brief the point arithmetic operation
                 * */
                
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <stdint.h>
                #include <string.h>
                
                #include "curves.h"
                #include "field.h"
                #include "ecc.h"
                #include "point.h"
                
                #define UMAX(a, b) a>b ? a : b
                #define ERROR(info) fprintf(stderr, "[%s:%d]%s\n    %s", __FILE__, \
                                __LINE__, __func__, info) 
                
                int ecc_decrypt(uint8_t **m, size_t *m_len, uint8_t *c, 
                                        size_t c_len, uint8_t *key)
         100 -> {
                
                    size_t num_digit = c_len - ECC_CURVE;
                    uint8_t *ret = (uint8_t *)malloc(num_digit);
                
                    uint64_t sk[NUM_ECC_DIGITS];
                    ecc_bytes2native(sk, key);
                
                    EccPoint p;
                    ecc_point_decompress(&p, c);         /* get the k*G */
                
                    EccPoint_mult(&p, &curve_G, sk);   /* get the s*G */
                
                    uint64_t res[NUM_ECC_DIGITS];
                    uint64_t r[NUM_ECC_DIGITS];
                    uint64_t *l = p.x;
                
                    uint8_t *rpt = c + ECC_CURVE + 1;
                    uint8_t *respt = ret;
                
                    int i=0;
                    
                    for(i=0; i<num_digit; ++i) 
                    {
                
                        ecc_bytes2native(r,rpt);
                        vli_xor(res, l, r);
                        ecc_native2bytes(respt, res);
                        
                        rpt += ECC_CURVE;
                        respt += ECC_CURVE;
                    }
                
                    *m = ret;
                    *m_len = num_digit;
                    return 1;
                
                end:
                    free(ret);
                    return 0;
                    
                
                
                }


Top 10 Lines:

     Line      Count

       25        100

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      100   Total number of line executions
   100.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/point/point_dbl.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <stdint.h>
                
                #include "curves.h"
                #include "field.h"
                #include "point.h"
                
                /* Point multiplication algorithm using Montgomery's ladder with co-Z coordinates.
                From http://eprint.iacr.org/2011/338.pdf
                */
                
                /* Double in place */
                void EccPoint_double_jacobian(uint64_t *X1, uint64_t *Y1, uint64_t *Z1)
      180117 -> {
                
                    uint64_t t1[NUM_ECC_DIGITS];
                    uint64_t t2[NUM_ECC_DIGITS];
                    uint64_t t3[NUM_ECC_DIGITS];
                    uint64_t X3[NUM_ECC_DIGITS];
                    uint64_t Y3[NUM_ECC_DIGITS];
                    uint64_t Z3[NUM_ECC_DIGITS];
                    uint64_t three[NUM_ECC_DIGITS] = {0};
                    three[0] = 3;
                
                    if(vli_isZero(Z1))
                    {
                        return;
                    }
                
                    // check the infinity
                
                    vli_modSquare_fast(t1, Z1);
                    vli_modSub(t2, X1, t1, curve_p);
                    vli_modAdd(t1, X1, t1, curve_p);
                    vli_modMult_fast(t2, t2, t1);
                
                    vli_modMult_fast(t2, t2, three);
                    vli_modAdd(Y3, Y1, Y1, curve_p);
                    vli_modMult_fast(Z3, Y3, Z1);
                    vli_modSquare_fast(Y3, Y3);
                
                    vli_modMult_fast(t3, Y3, X1);
                    vli_modSquare_fast(Y3, Y3);
                    vli_rshift1(Y3);
                    vli_modSquare_fast(X3, t2);
                
                    vli_modAdd(t1, t3, t3, curve_p);
                    vli_modSub(X3, X3, t1, curve_p);
                    vli_modSub(t1, t3, X3, curve_p);
                    vli_modMult_fast(t1, t1, t2);
                
                    vli_modSub(Y3, t1, Y3, curve_p);
                
                    vli_set(X1, X3);
                    vli_set(Y1, Y3);
                    vli_set(Z1, Z3);
                }
                
                void EccPoint_double_jacobian_origin(uint64_t *X1, uint64_t *Y1, uint64_t *Z1)
       ##### -> {
                    /* t1 = X, t2 = Y, t3 = Z */
                    uint64_t t4[NUM_ECC_DIGITS];
                    uint64_t t5[NUM_ECC_DIGITS];
                    
                    if(vli_isZero(Z1))
                    {
                        return;
                    }
                    
                    vli_modSquare_fast(t4, Y1);   /* t4 = y1^2 */
                    vli_modMult_fast(t5, X1, t4); /* t5 = x1*y1^2 = A */
                    vli_modSquare_fast(t4, t4);   /* t4 = y1^4 */
                    vli_modMult_fast(Y1, Y1, Z1); /* t2 = y1*z1 = z3 */
                    vli_modSquare_fast(Z1, Z1);   /* t3 = z1^2 */
                    
                    vli_modAdd(X1, X1, Z1, curve_p); /* t1 = x1 + z1^2 */
                    vli_modAdd(Z1, Z1, Z1, curve_p); /* t3 = 2*z1^2 */
                    vli_modSub(Z1, X1, Z1, curve_p); /* t3 = x1 - z1^2 */
                    vli_modMult_fast(X1, X1, Z1);    /* t1 = x1^2 - z1^4 */
                    
                    vli_modAdd(Z1, X1, X1, curve_p); /* t3 = 2*(x1^2 - z1^4) */
                    vli_modAdd(X1, X1, Z1, curve_p); /* t1 = 3*(x1^2 - z1^4) */
                    if(vli_testBit(X1, 0))
                    {   /* t1 is an odd integer, add p to the t1, making it an even integer */
                        uint64_t l_carry = vli_add(X1, X1, curve_p);
                        vli_rshift1(X1);
                        X1[NUM_ECC_DIGITS-1] |= l_carry << 63;      /* unify the overflow and unoverflow conditions */
                    }
                    else
                    {
                        vli_rshift1(X1);
                    }
                    /* t1 = 3/2*(x1^2 - z1^4) = B */
                    
                    vli_modSquare_fast(Z1, X1);      /* t3 = B^2 */
                    vli_modSub(Z1, Z1, t5, curve_p); /* t3 = B^2 - A */
                    vli_modSub(Z1, Z1, t5, curve_p); /* t3 = B^2 - 2A = x3 */
                    vli_modSub(t5, t5, Z1, curve_p); /* t5 = A - x3 */
                    vli_modMult_fast(X1, X1, t5);    /* t1 = B * (A - x3) */
                    vli_modSub(t4, X1, t4, curve_p); /* t4 = B * (A - x3) - y1^4 = y3 */
                    
                    vli_set(X1, Z1);
                    vli_set(Z1, Y1);
                    vli_set(Y1, t4);
                }


Top 10 Lines:

     Line      Count

       15     180117

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

   180117   Total number of line executions
 90058.50   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/field/field_sub.c:
                #include <curves.h>
                #include <field.h>
                
                uint64_t vli_sub(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
    23303637 -> {
                    uint64_t l_borrow = 0;
                    uint i;
                    for(i=0; i<NUM_ECC_DIGITS; ++i)
                    {
                        uint64_t l_diff = p_left[i] - p_right[i] - l_borrow;
                        if(l_diff != p_left[i])
                        {
                            l_borrow = (l_diff > p_left[i]);
                        }
                        p_result[i] = l_diff;
                    }
                    return l_borrow;
                }
                
                /* Computes p_result = (p_left - p_right) % p_mod.
                   Assumes that p_left < p_mod and p_right < p_mod, p_result != p_mod. */
                void vli_modSub(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right, uint64_t *p_mod)
     2341402 -> {
                    uint64_t l_borrow = vli_sub(p_result, p_left, p_right);
                    if(l_borrow)
                    { /* In this case, p_result == -diff == (max int) - diff.
                         Since -x % d == d - x, we can get the correct result from p_result + p_mod (with overflow). */
                        vli_add(p_result, p_result, p_mod);
                    }
                }


Top 10 Lines:

     Line      Count

        5   23303637
       23    2341402

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

 25645039   Total number of line executions
12822519.50   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/field/field_mod.c:
                #include <curves.h>
                #include <field.h>
                
                
                #if ECC_CURVE == secp128r1
                
                /* Computes p_result = p_product % curve_p.
                   See algorithm 5 and 6 from http://www.isys.uni-klu.ac.at/PDF/2001-0126-MT.pdf */
                void vli_mmod_fast(uint64_t *p_result, uint64_t *p_product)
                {
                    uint64_t l_tmp[NUM_ECC_DIGITS];
                    int l_carry;
                    
                    vli_set(p_result, p_product);
                    
                    l_tmp[0] = p_product[2];
                    l_tmp[1] = (p_product[3] & 0x1FFFFFFFFull) | (p_product[2] << 33);
                    l_carry = vli_add(p_result, p_result, l_tmp);
                    
                    l_tmp[0] = (p_product[2] >> 31) | (p_product[3] << 33);
                    l_tmp[1] = (p_product[3] >> 31) | ((p_product[2] & 0xFFFFFFFF80000000ull) << 2);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    l_tmp[0] = (p_product[2] >> 62) | (p_product[3] << 2);
                    l_tmp[1] = (p_product[3] >> 62) | ((p_product[2] & 0xC000000000000000ull) >> 29) | (p_product[3] << 35);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    l_tmp[0] = (p_product[3] >> 29);
                    l_tmp[1] = ((p_product[3] & 0xFFFFFFFFE0000000ull) << 4);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    l_tmp[0] = (p_product[3] >> 60);
                    l_tmp[1] = (p_product[3] & 0xFFFFFFFE00000000ull);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    l_tmp[0] = 0;
                    l_tmp[1] = ((p_product[3] & 0xF000000000000000ull) >> 27);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    while(l_carry || vli_cmp(curve_p, p_result) != 1)
                    {
                        l_carry -= vli_sub(p_result, p_result, curve_p);
                    }
                }
                
                #elif ECC_CURVE == secp192r1
                
                /* Computes p_result = p_product % curve_p.
                   See algorithm 5 and 6 from http://www.isys.uni-klu.ac.at/PDF/2001-0126-MT.pdf */
                void vli_mmod_fast(uint64_t *p_result, uint64_t *p_product)
                {
                    uint64_t l_tmp[NUM_ECC_DIGITS];
                    int l_carry;
                    
                    vli_set(p_result, p_product);
                    
                    vli_set(l_tmp, &p_product[3]);
                    l_carry = vli_add(p_result, p_result, l_tmp);
                    
                    l_tmp[0] = 0;
                    l_tmp[1] = p_product[3];
                    l_tmp[2] = p_product[4];
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    l_tmp[0] = l_tmp[1] = p_product[5];
                    l_tmp[2] = 0;
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    while(l_carry || vli_cmp(curve_p, p_result) != 1)
                    {
                        l_carry -= vli_sub(p_result, p_result, curve_p);
                    }
                }
                
                #elif ECC_CURVE == secp256r1
                
                /* Computes p_result = p_product % curve_p
                   from http://www.nsa.gov/ia/_files/nist-routines.pdf */
                void vli_mmod_fast(uint64_t *p_result, uint64_t *p_product)
     5040320 -> {
                    uint64_t l_tmp[NUM_ECC_DIGITS];
                    int l_carry;
                    
                    /* t */
                    vli_set(p_result, p_product);
                    
                    /* s1 */
                    l_tmp[0] = 0;
                    l_tmp[1] = p_product[5] & 0xffffffff00000000ull;
                    l_tmp[2] = p_product[6];
                    l_tmp[3] = p_product[7];
                    l_carry = vli_lshift(l_tmp, l_tmp, 1);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    /* s2 */
                    l_tmp[1] = p_product[6] << 32;
                    l_tmp[2] = (p_product[6] >> 32) | (p_product[7] << 32);
                    l_tmp[3] = p_product[7] >> 32;
                    l_carry += vli_lshift(l_tmp, l_tmp, 1);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    /* s3 */
                    l_tmp[0] = p_product[4];
                    l_tmp[1] = p_product[5] & 0xffffffff;
                    l_tmp[2] = 0;
                    l_tmp[3] = p_product[7];
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    /* s4 */
                    l_tmp[0] = (p_product[4] >> 32) | (p_product[5] << 32);
                    l_tmp[1] = (p_product[5] >> 32) | (p_product[6] & 0xffffffff00000000ull);
                    l_tmp[2] = p_product[7];
                    l_tmp[3] = (p_product[6] >> 32) | (p_product[4] << 32);
                    l_carry += vli_add(p_result, p_result, l_tmp);
                    
                    /* d1 */
                    l_tmp[0] = (p_product[5] >> 32) | (p_product[6] << 32);
                    l_tmp[1] = (p_product[6] >> 32);
                    l_tmp[2] = 0;
                    l_tmp[3] = (p_product[4] & 0xffffffff) | (p_product[5] << 32);
                    l_carry -= vli_sub(p_result, p_result, l_tmp);
                    
                    /* d2 */
                    l_tmp[0] = p_product[6];
                    l_tmp[1] = p_product[7];
                    l_tmp[2] = 0;
                    l_tmp[3] = (p_product[4] >> 32) | (p_product[5] & 0xffffffff00000000ull);
                    l_carry -= vli_sub(p_result, p_result, l_tmp);
                    
                    /* d3 */
                    l_tmp[0] = (p_product[6] >> 32) | (p_product[7] << 32);
                    l_tmp[1] = (p_product[7] >> 32) | (p_product[4] << 32);
                    l_tmp[2] = (p_product[4] >> 32) | (p_product[5] << 32);
                    l_tmp[3] = (p_product[6] << 32);
                    l_carry -= vli_sub(p_result, p_result, l_tmp);
                    
                    /* d4 */
                    l_tmp[0] = p_product[7];
                    l_tmp[1] = p_product[4] & 0xffffffff00000000ull;
                    l_tmp[2] = p_product[5];
                    l_tmp[3] = p_product[6] & 0xffffffff00000000ull;
                    l_carry -= vli_sub(p_result, p_result, l_tmp);
                    
                    if(l_carry < 0)
                    {
                        do
                        {
                            l_carry += vli_add(p_result, p_result, curve_p);
                        } while(l_carry < 0);
                    }
                    else
                    {
                        while(l_carry || vli_cmp(curve_p, p_result) != 1)
                        {
                            l_carry -= vli_sub(p_result, p_result, curve_p);
                        }
                    }
                }
                
                #elif ECC_CURVE == secp384r1
                
                void omega_mult(uint64_t *p_result, uint64_t *p_right)
                {
                    uint64_t l_tmp[NUM_ECC_DIGITS];
                    uint64_t l_carry, l_diff;
                    
                    /* Multiply by (2^128 + 2^96 - 2^32 + 1). */
                    vli_set(p_result, p_right); /* 1 */
                    l_carry = vli_lshift(l_tmp, p_right, 32);
                    p_result[1 + NUM_ECC_DIGITS] = l_carry + vli_add(p_result + 1, p_result + 1, l_tmp); /* 2^96 + 1 */
                    p_result[2 + NUM_ECC_DIGITS] = vli_add(p_result + 2, p_result + 2, p_right); /* 2^128 + 2^96 + 1 */
                    l_carry += vli_sub(p_result, p_result, l_tmp); /* 2^128 + 2^96 - 2^32 + 1 */
                    l_diff = p_result[NUM_ECC_DIGITS] - l_carry;
                    if(l_diff > p_result[NUM_ECC_DIGITS])
                    { /* Propagate borrow if necessary. */
                        uint i;
                        for(i = 1 + NUM_ECC_DIGITS; ; ++i)
                        {
                            --p_result[i];
                            if(p_result[i] != (uint64_t)-1)
                            {
                                break;
                            }
                        }
                    }
                    p_result[NUM_ECC_DIGITS] = l_diff;
                }
                
                /* Computes p_result = p_product % curve_p
                    see PDF "Comparing Elliptic Curve Cryptography and RSA on 8-bit CPUs"
                    section "Curve-Specific Optimizations" */
                void vli_mmod_fast(uint64_t *p_result, uint64_t *p_product)
                {
                    uint64_t l_tmp[2*NUM_ECC_DIGITS];
                     
                    while(!vli_isZero(p_product + NUM_ECC_DIGITS)) /* While c1 != 0 */
                    {
                        uint64_t l_carry = 0;
                        uint i;
                        
                        vli_clear(l_tmp);
                        vli_clear(l_tmp + NUM_ECC_DIGITS);
                        omega_mult(l_tmp, p_product + NUM_ECC_DIGITS); /* tmp = w * c1 */
                        vli_clear(p_product + NUM_ECC_DIGITS); /* p = c0 */
                        
                        /* (c1, c0) = c0 + w * c1 */
                        for(i=0; i<NUM_ECC_DIGITS+3; ++i)
                        {
                            uint64_t l_sum = p_product[i] + l_tmp[i] + l_carry;
                            if(l_sum != p_product[i])
                            {
                                l_carry = (l_sum < p_product[i]);
                            }
                            p_product[i] = l_sum;
                        }
                    }
                    
                    while(vli_cmp(p_product, curve_p) > 0)
                    {
                        vli_sub(p_product, p_product, curve_p);
                    }
                    vli_set(p_result, p_product);
                }
                
                #endif
                


Top 10 Lines:

     Line      Count

       80    5040320

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

  5040320   Total number of line executions
5040320.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/field/field_sqrt.c:
                #include <curves.h>
                #include <field.h>
                
                /* Compute a = sqrt(a) (mod curve_p). */
                void mod_sqrt(uint64_t a[NUM_ECC_DIGITS])
         304 -> {
                    unsigned i;
                    uint64_t p1[NUM_ECC_DIGITS] = {1};
                    uint64_t l_result[NUM_ECC_DIGITS] = {1};
                    
                    /* Since curve_p == 3 (mod 4) for all supported curves, we can
                       compute sqrt(a) = a^((curve_p + 1) / 4) (mod curve_p). */
                    vli_add(p1, curve_p, p1); /* p1 = curve_p + 1 */
                    for(i = vli_numBits(p1) - 1; i > 1; --i)
                    {
                        vli_modSquare_fast(l_result, l_result);
                        if(vli_testBit(p1, i))
                        {
                            vli_modMult_fast(l_result, l_result, a);
                        }
                    }
                    vli_set(a, l_result);
                }


Top 10 Lines:

     Line      Count

        6        304

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      304   Total number of line executions
   304.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/point/point_mul.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <stdint.h>
                
                #include <curves.h>
                #include <field.h>
                #include <point.h>
                
                /* ------ Point operations ------ */
                
                /* P = (x1, y1) => 2P, (x2, y2) => P' */
                /* 
                    Result : 
                        2P = (X1, Y1, Z)
                        P = (X2, Y2, Z)
                 */
                void XYcZ_initial_double(uint64_t *X1, uint64_t *Y1, uint64_t *X2, uint64_t *Y2, uint64_t *p_initialZ)
       ##### -> {
                    // uint64_t z[NUM_ECC_DIGITS];
                    
                    // vli_set(X2, X1);
                    // vli_set(Y2, Y1);
                    
                    // vli_clear(z);
                    // z[0] = 1;
                    // if(p_initialZ)
                    // {
                    //     vli_set(z, p_initialZ);
                    // }
                
                    // apply_z(X1, Y1, z);
                    
                    // EccPoint_double_jacobian(X1, Y1, z);
                    
                    // apply_z(X2, Y2, z);
                
                    uint64_t *t1 = X1, *t2 = X2; 
                    uint64_t t3[NUM_ECC_DIGITS], t4[NUM_ECC_DIGITS];
                    uint64_t t5[NUM_ECC_DIGITS], t6[NUM_ECC_DIGITS];
                
                    vli_modSquare_fast(t3, t1);
                    vli_modAdd(t4, t3, t3, curve_p);
                    vli_modAdd(t3, t3, t4, curve_p);
                    vli_modAdd(t3, t3, curve_a, curve_p); 
                
                    vli_modSquare_fast(t4, t2);
                    vli_modAdd(t4, t4, t4, curve_p);
                    vli_modAdd(t5, t4, t4, curve_p);
                    vli_modMult_fast(t5, t5, t1);
                
                    vli_modSquare_fast(t6, t3);
                    vli_modSub(t6, t6, t5, curve_p);
                    vli_modSub(t6, t6, t5, curve_p);
                    vli_modSub(t1, t5, t6, curve_p);
                
                    vli_modMult_fast(t1, t1, t3);
                    vli_modSquare_fast(t3, t4);
                    vli_modAdd(t3, t3, t3, curve_p);
                    vli_modSub(t1, t1, t3, curve_p);
                
                    vli_set(X2, t6);
                    vli_set(Y2, t1);
                    vli_set(X1, t5);
                    vli_set(Y1, t3);
                
                }
                
                /*
                    Algorithm 9 : Montgomery ladder with (X,Y)-only co-Z addition
                 */
                void EccPoint_mult_plain(EccPoint *p_result, EccPoint *p_point, uint64_t *p_scalar, uint64_t *p_initialZ)
       ##### -> {
                    /* R0 and R1 */
                    /* R0 = (Rx[0], Ry[0]) */
                    /* R1 = (Rx[1], Ry[1]) */
                    uint64_t Rx[2][NUM_ECC_DIGITS];
                    uint64_t Ry[2][NUM_ECC_DIGITS];
                    uint64_t z[NUM_ECC_DIGITS];
                    
                    int i, nb;
                    
                    vli_set(Rx[1], p_point->x);
                    vli_set(Ry[1], p_point->y);
                
                    XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], p_initialZ);        /* R[1] = 2P and R[0] = P */
                
                    for(i = vli_numBits(p_scalar) - 2; i > 0; --i)
                    {
                        nb = !vli_testBit(p_scalar, i);
                        XYcZ_addC(Rx[1-nb], Ry[1-nb], Rx[nb], Ry[nb]);
                        XYcZ_add(Rx[nb], Ry[nb], Rx[1-nb], Ry[1-nb]);
                    }
                
                    nb = !vli_testBit(p_scalar, 0);
                    XYcZ_addC(Rx[1-nb], Ry[1-nb], Rx[nb], Ry[nb]);
                    
                    /* Find final 1/Z value. */
                    vli_modSub(z, Rx[1], Rx[0], curve_p); /* X1 - X0 */
                    vli_modMult_fast(z, z, Ry[1-nb]);     /* Yb * (X1 - X0) */
                    vli_modMult_fast(z, z, p_point->x);   /* xP * Yb * (X1 - X0) */
                    vli_modInv(z, z, curve_p);            /* 1 / (xP * Yb * (X1 - X0)) */
                    vli_modMult_fast(z, z, p_point->y);   /* yP / (xP * Yb * (X1 - X0)) */
                    vli_modMult_fast(z, z, Rx[1-nb]);     /* Xb * yP / (xP * Yb * (X1 - X0)) */
                    /* End 1/Z calculation */
                
                    XYcZ_add(Rx[nb], Ry[nb], Rx[1-nb], Ry[1-nb]);
                    
                    apply_z(Rx[0], Ry[0], z);
                    
                    vli_set(p_result->x, Rx[0]);
                    vli_set(p_result->y, Ry[0]);
                }
                
                void EccPoint_mult(EccPoint *p_result, EccPoint *p_point, uint64_t *p_scalar /*, uint64_t *p_initialZ */)
         709 -> {
                    /* R0 and R1 */
                    /* R0 = (Rx[0], Ry[0]) */
                    /* R1 = (Rx[1], Ry[1]) */
                
                    int len = vli_numBits(p_scalar); /* get the length of the scalar */
                
                    uint64_t Rx[NUM_ECC_DIGITS];
                    uint64_t Ry[NUM_ECC_DIGITS];
                    uint64_t Px[NUM_ECC_DIGITS];
                    uint64_t Py[NUM_ECC_DIGITS];
                    uint64_t Tx[NUM_ECC_DIGITS];
                    uint64_t Ty[NUM_ECC_DIGITS];
                    uint64_t Tz[NUM_ECC_DIGITS];
                
                    /* initialize the result as P */
                    vli_set(Rx, p_point->x);
                    vli_set(Ry, p_point->y);
                
                
                    int i;
                    for(i=len-2; i>=0; --i)
                    {
                
                        uint64_t Rz[NUM_ECC_DIGITS] = {1};
                        vli_set(Tx, Rx);
                        vli_set(Ty, Ry);
                        vli_set(Tz, Rz);
                        vli_set(Px, Rx);
                        vli_set(Py, Ry);
                        
                        EccPoint_add_jacobian(Rx, Ry, Rz, Tx, Ty, Tz, Px, Py);
                        // EccPoint_double_jacobian(Rx, Ry, Rz);
                        // apply_z(Rx, Ry, Rz);
                
                
                        if(0 != vli_testBit(p_scalar, i)) /* this bit is not zero */
                        {
                
                            // XYcZ_add(Rx[0], Ry[0], Rx[1], Ry[1]);
                            uint64_t Rz[NUM_ECC_DIGITS] = {1};
                            vli_set(Tx, Rx);
                            vli_set(Ty, Ry);
                            vli_set(Tz, Rz);
                            
                            EccPoint_add_jacobian(Rx, Ry, Rz, Tx, Ty, Tz, p_point->x, p_point->y);
                            apply_z(Rx, Ry, Rz);
                
                        }
                
                    }
                
                    vli_set(p_result->x, Rx);
                    vli_set(p_result->y, Ry);
                }

Top 10 Lines:

     Line      Count

      115        709

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

      709   Total number of line executions
   236.33   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/ecc/ecc_make_key.c:
                /** !
                 * @file ecc_opt.c
                 * @author Wang Ruikai 
                 * @date July 15th, 2019
                 * @brief the point arithmetic operation
                 * */
                
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <stdint.h>
                #include <string.h>
                
                #include "curves.h"
                #include "field.h"
                #include "ecc.h"
                #include "point.h"
                
                #define UMAX(a, b) a>b ? a : b
                #define ERROR(info) fprintf(stderr, "[%s:%d]%s\n    %s", __FILE__, \
                                __LINE__, __func__, info) 
                
                int ecc_make_key(uint8_t p_publicKey[ECC_BYTES+1], 
                                uint8_t p_privateKey[ECC_BYTES])
         100 -> {
                    uint64_t l_private[NUM_ECC_DIGITS];
                    EccPoint l_public;
                    unsigned l_tries = 0;
                    
                    do
                    {
                        if(!getRandomNumber(l_private) || (l_tries++ >= MAX_TRIES))
                        {
                            return 0;
                        }
                        if(vli_isZero(l_private))
                        {
                            continue;
                        }
                    
                        /* Make sure the private key is in the range [1, n-1].
                           For the supported curves, n is always large enough 
                           that we only need to subtract once at most. */
                        if(vli_cmp(curve_n, l_private) != 1)
                        {
                            vli_sub(l_private, l_private, curve_n);
                        }
                
                        EccPoint_mult(&l_public, &curve_G, l_private);
                    } while(EccPoint_isZero(&l_public));
                    
                    ecc_native2bytes(p_privateKey, l_private);
                    ecc_native2bytes(p_publicKey + 1, l_public.x);
                    p_publicKey[0] = 2 + (l_public.y[0] & 0x01);
                    return 1;
                }


Top 10 Lines:

     Line      Count

       25        100

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      100   Total number of line executions
   100.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/point/point.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <stdint.h>
                
                #include "curves.h"
                #include "field.h"
                #include "point.h"
                
                /* ------ Point operations ------ */
                
                /* Returns 1 if p_point is the point at infinity, 0 otherwise. */
                int EccPoint_isZero(EccPoint *p_point)
         201 -> {
                    return (vli_isZero(p_point->x) && vli_isZero(p_point->y));
                }
                
                
                /* Modify (x1, y1) => (x1 * z^2, y1 * z^3) */
                /*
                    this function is to convert ordinary (x,y) tuples to Jacobian-affine coordinates (X,Y,Z) 
                 */
                void apply_z(uint64_t *X1, uint64_t *Y1, uint64_t *Z)
       89988 -> {
                    uint64_t t1[NUM_ECC_DIGITS];
                
                    vli_modSquare_fast(t1, Z);    /* z^2 */
                    vli_modMult_fast(X1, X1, t1); /* x1 * z^2 */
                    vli_modMult_fast(t1, t1, Z);  /* z^3 */
                    vli_modMult_fast(Y1, Y1, t1); /* y1 * z^3 */
                }
                
                
                void ecc_point_decompress(EccPoint *p_point, const uint8_t p_compressed[ECC_BYTES+1])
         304 -> {   /* get the point from the x coordinate */
                    uint64_t _3[NUM_ECC_DIGITS] = {3}; /* -a = 3 */
                    ecc_bytes2native(p_point->x, p_compressed+1);
                    
                    vli_modSquare_fast(p_point->y, p_point->x); /* y = x^2 */
                    vli_modSub(p_point->y, p_point->y, _3, curve_p); /* y = x^2 - 3 */
                    vli_modMult_fast(p_point->y, p_point->y, p_point->x); /* y = x^3 - 3x */
                    vli_modAdd(p_point->y, p_point->y, curve_b, curve_p); /* y = x^3 - 3x + b */
                    
                    mod_sqrt(p_point->y);
                    
                    if((p_point->y[0] & 0x01) != (p_compressed[0] & 0x01))
                    {/* seems like that the first bits of coordinates are used to represent that the 
                        location of the point, upsides the x-axis or downsides */
                        vli_sub(p_point->y, curve_p, p_point->y);
                    }
                }


Top 10 Lines:

     Line      Count

       23      89988
       34        304
       13        201

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

    90493   Total number of line executions
 30164.33   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/field/field_add.c:
                #include <curves.h>
                #include <field.h>
                
                /* Computes p_result = p_left + p_right, returning carry. Can modify in place. */
                uint64_t vli_add(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
    22333354 -> {
                    uint64_t l_carry = 0;
                    uint i;
                    for(i=0; i<NUM_ECC_DIGITS; ++i)
                    {
                        uint64_t l_sum = p_left[i] + p_right[i] + l_carry;
                        if(l_sum != p_left[i])
                        {
                            l_carry = (l_sum < p_left[i]);
                        }
                        p_result[i] = l_sum;
                    }
                    return l_carry;
                }
                
                
                #if SUPPORTS_INT128
                
                
                #else /* #if SUPPORTS_INT128 */
                
                uint128_t add_128_128(uint128_t a, uint128_t b)
                {
                    uint128_t l_result;
                    l_result.m_low = a.m_low + b.m_low;
                    l_result.m_high = a.m_high + b.m_high + (l_result.m_low < a.m_low);
                    return l_result;
                }
                
                
                #endif /* SUPPORTS_INT128 */
                
                
                /* Computes p_result = (p_left + p_right) % p_mod.
                   Assumes that p_left < p_mod and p_right < p_mod, p_result != p_mod. */
                void vli_modAdd(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right, uint64_t *p_mod)
      810760 -> {
                    uint64_t l_carry = vli_add(p_result, p_left, p_right);
                    if(l_carry || vli_cmp(p_result, p_mod) >= 0)
                    { /* p_result > p_mod (p_result = p_mod + remainder), so subtract p_mod to get remainder. */
                        vli_sub(p_result, p_result, p_mod);
                    }
                }
                


Top 10 Lines:

     Line      Count

        6   22333354
       42     810760

Execution Summary:

        2   Executable lines in this file
        2   Lines executed
   100.00   Percent of the file executed

 23144114   Total number of line executions
11572057.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/field/field_mul.c:
                #include <curves.h>
                #include <field.h>
                
                
                #if SUPPORTS_INT128
                
                /* Computes p_result = p_left * p_right. */
                void vli_mult(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
     3342029 -> {
                    uint128_t r01 = 0;
                    uint64_t r2 = 0;
                    
                    uint i, k;
                    
                    /* Compute each digit of p_result in sequence, maintaining the carries. */
                    for(k=0; k < NUM_ECC_DIGITS*2 - 1; ++k)
                    {
                        uint l_min = (k < NUM_ECC_DIGITS ? 0 : (k + 1) - NUM_ECC_DIGITS);
                        for(i=l_min; i<=k && i<NUM_ECC_DIGITS; ++i)
                        {
                            uint128_t l_product = (uint128_t)p_left[i] * p_right[k-i];
                            r01 += l_product;
                            r2 += (r01 < l_product);
                        }
                        p_result[k] = (uint64_t)r01;
                        r01 = (r01 >> 64) | (((uint128_t)r2) << 64);
                        r2 = 0;
                    }
                    
                    p_result[NUM_ECC_DIGITS*2 - 1] = (uint64_t)r01;
                }
                
                #else /* #if SUPPORTS_INT128 */
                
                uint128_t mul_64_64(uint64_t p_left, uint64_t p_right)
                {
                    uint128_t l_result;
                    
                    uint64_t a0 = p_left & 0xffffffffull;
                    uint64_t a1 = p_left >> 32;
                    uint64_t b0 = p_right & 0xffffffffull;
                    uint64_t b1 = p_right >> 32;
                    
                    uint64_t m0 = a0 * b0;
                    uint64_t m1 = a0 * b1;
                    uint64_t m2 = a1 * b0;
                    uint64_t m3 = a1 * b1;
                    
                    m2 += (m0 >> 32);
                    m2 += m1;
                    if(m2 < m1)
                    { // overflow
                        m3 += 0x100000000ull;
                    }
                    
                    l_result.m_low = (m0 & 0xffffffffull) | (m2 << 32);
                    l_result.m_high = m3 + (m2 >> 32);
                    
                    return l_result;
                }
                
                void vli_mult(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
                {
                    uint128_t r01 = {0, 0};
                    uint64_t r2 = 0;
                    
                    uint i, k;
                    
                    /* Compute each digit of p_result in sequence, maintaining the carries. */
                    for(k=0; k < NUM_ECC_DIGITS*2 - 1; ++k)
                    {
                        uint l_min = (k < NUM_ECC_DIGITS ? 0 : (k + 1) - NUM_ECC_DIGITS);
                        for(i=l_min; i<=k && i<NUM_ECC_DIGITS; ++i)
                        {
                            uint128_t l_product = mul_64_64(p_left[i], p_right[k-i]);
                            r01 = add_128_128(r01, l_product);
                            r2 += (r01.m_high < l_product.m_high);  /* overflow */
                        }
                        p_result[k] = r01.m_low;    /* right shift */
                        r01.m_low = r01.m_high;
                        r01.m_high = r2;
                        r2 = 0;
                    }
                    
                    p_result[NUM_ECC_DIGITS*2 - 1] = r01.m_low;
                }
                
                #endif /* SUPPORTS_INT128 */
                
                /* Computes p_result = (p_left * p_right) % curve_p. */
                void vli_modMult_fast(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
     3342029 -> {
                    uint64_t l_product[2 * NUM_ECC_DIGITS];
                    vli_mult(l_product, p_left, p_right);
                    vli_mmod_fast(p_result, l_product);
                }
                
                
                /* Computes p_result = (p_left * p_right) % p_mod. */
                void vli_modMult(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right, uint64_t *p_mod)
       ##### -> {
                    uint64_t l_product[2 * NUM_ECC_DIGITS];
                    uint64_t l_modMultiple[2 * NUM_ECC_DIGITS];
                    uint l_digitShift, l_bitShift;
                    uint l_productBits;
                    uint l_modBits = vli_numBits(p_mod);
                    
                    vli_mult(l_product, p_left, p_right);
                    l_productBits = vli_numBits(l_product + NUM_ECC_DIGITS);
                    if(l_productBits)
                    {
                        l_productBits += NUM_ECC_DIGITS * 64;
                    }
                    else
                    {
                        l_productBits = vli_numBits(l_product);
                    }
                    
                    if(l_productBits < l_modBits)
                    { /* l_product < p_mod. */
                        vli_set(p_result, l_product);
                        return;
                    }
                    
                    /* Shift p_mod by (l_leftBits - l_modBits). This multiplies p_mod by the largest
                       power of two possible while still resulting in a number less than p_left. */
                    vli_clear(l_modMultiple);
                    vli_clear(l_modMultiple + NUM_ECC_DIGITS);
                    l_digitShift = (l_productBits - l_modBits) / 64;
                    l_bitShift = (l_productBits - l_modBits) % 64;
                    if(l_bitShift)
                    {
                        l_modMultiple[l_digitShift + NUM_ECC_DIGITS] = vli_lshift(l_modMultiple + l_digitShift, p_mod, l_bitShift);
                    }
                    else
                    {
                        vli_set(l_modMultiple + l_digitShift, p_mod);
                    }
                
                    /* Subtract all multiples of p_mod to get the remainder. */
                    vli_clear(p_result);
                    p_result[0] = 1; /* Use p_result as a temp var to store 1 (for subtraction) */
                    while(l_productBits > NUM_ECC_DIGITS * 64 || vli_cmp(l_modMultiple, p_mod) >= 0)
                    {
                        int l_cmp = vli_cmp(l_modMultiple + NUM_ECC_DIGITS, l_product + NUM_ECC_DIGITS);
                        if(l_cmp < 0 || (l_cmp == 0 && vli_cmp(l_modMultiple, l_product) <= 0))
                        {
                            if(vli_sub(l_product, l_product, l_modMultiple))
                            { /* borrow */
                                vli_sub(l_product + NUM_ECC_DIGITS, l_product + NUM_ECC_DIGITS, p_result);
                            }
                            vli_sub(l_product + NUM_ECC_DIGITS, l_product + NUM_ECC_DIGITS, l_modMultiple + NUM_ECC_DIGITS);
                        }
                        uint64_t l_carry = (l_modMultiple[NUM_ECC_DIGITS] & 0x01) << 63;
                        vli_rshift1(l_modMultiple + NUM_ECC_DIGITS);
                        vli_rshift1(l_modMultiple);
                        l_modMultiple[NUM_ECC_DIGITS-1] |= l_carry;
                        
                        --l_productBits;
                    }
                    vli_set(p_result, l_product);
                }
                


Top 10 Lines:

     Line      Count

        9    3342029
       92    3342029

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

  6684058   Total number of line executions
2228019.33   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/field/field.c:
                #include <curves.h>
                #include <field.h>
                
                
                void vli_clear(uint64_t *p_vli)
       ##### -> {
                    uint i;
                    for(i=0; i<NUM_ECC_DIGITS; ++i)
                    {
                        p_vli[i] = 0;
                    }
                }
                
                /* Returns 1 if p_vli == 0, 0 otherwise. */
                int vli_isZero(uint64_t *p_vli)
      901455 -> {
                    uint i;
                    for(i = 0; i < NUM_ECC_DIGITS; ++i)
                    {
                        if(p_vli[i])
                        {
                            return 0;
                        }
                    }
                    return 1;
                }
                
                /* Returns nonzero if bit p_bit of p_vli is set. */
                uint64_t vli_testBit(uint64_t *p_vli, uint p_bit)
      257333 -> {
                    return (p_vli[p_bit/64] & ((uint64_t)1 << (p_bit % 64)));
                }
                
                /* Counts the number of 64-bit "digits" in p_vli. */
                uint vli_numDigits(uint64_t *p_vli)
        1013 -> {
                    int i;
                    /* Search from the end until we find a non-zero digit.
                       We do it in reverse because we expect that most digits will be nonzero. */
                    for(i = NUM_ECC_DIGITS - 1; i >= 0 && p_vli[i] == 0; --i)
                    {
                    }
                
                    return (i + 1);
                }
                
                /* Counts the number of bits required for p_vli. */
                uint vli_numBits(uint64_t *p_vli)
        1013 -> {
                    uint i;
                    uint64_t l_digit;
                    
                    uint l_numDigits = vli_numDigits(p_vli);
                    if(l_numDigits == 0)
                    {
                        return 0;
                    }
                
                    l_digit = p_vli[l_numDigits - 1];
                    for(i=0; l_digit; ++i)
                    {
                        l_digit >>= 1;
                    }
                    
                    return ((l_numDigits - 1) * 64 + i);
                }
                
                /* Sets p_dest = p_src. */
                void vli_set(uint64_t *p_dest, uint64_t *p_src)
     7294711 -> {
                    uint i;
                    for(i=0; i<NUM_ECC_DIGITS; ++i)
                    {
                        p_dest[i] = p_src[i];
                    }
                }
                
                /* Returns sign of p_left - p_right. */
                int vli_cmp(uint64_t *p_left, uint64_t *p_right)
     5227249 -> {
                    int i;
                    for(i = NUM_ECC_DIGITS-1; i >= 0; --i)
                    {
                        if(p_left[i] > p_right[i])
                        {
                            return 1;
                        }
                        else if(p_left[i] < p_right[i])
                        {
                            return -1;
                        }
                    }
                    return 0;
                }
                
                /* Computes p_result = p_in << c, returning carry. Can modify in place (if p_result == p_in). 0 < p_shift < 64. */
                uint64_t vli_lshift(uint64_t *p_result, uint64_t *p_in, uint p_shift)
    10080640 -> {
                    uint64_t l_carry = 0;
                    uint i;
                    for(i = 0; i < NUM_ECC_DIGITS; ++i)
                    {
                        uint64_t l_temp = p_in[i];
                        p_result[i] = (l_temp << p_shift) | l_carry;
                        l_carry = l_temp >> (64 - p_shift);
                    }
                    
                    return l_carry;
                }
                
                /* Computes p_vli = p_vli >> 1. */
                void vli_rshift1(uint64_t *p_vli)
      180117 -> {
                    uint64_t *l_end = p_vli;
                    uint64_t l_carry = 0;
                    
                    p_vli += NUM_ECC_DIGITS;
                    while(p_vli-- > l_end)
                    {
                        uint64_t l_temp = *p_vli;
                        *p_vli = (l_temp >> 1) | l_carry;
                        l_carry = l_temp << 63;
                    }
                }
                
                void vli_xor(uint64_t *p_result, uint64_t *p_left, uint64_t *p_right)
        3300 -> {
                
                    uint i;
                    for(i=0; i<NUM_ECC_DIGITS; ++i) 
                    {
                        p_result[i] = p_left[i] ^ p_right[i];
                    }
                
                }
                
                
                void ecc_bytes2native(uint64_t p_native[NUM_ECC_DIGITS], const uint8_t p_bytes[ECC_BYTES])
        3704 -> {
                    unsigned i;
                    for(i=0; i<NUM_ECC_DIGITS; ++i)
                    {
                        const uint8_t *p_digit = p_bytes + 8 * (NUM_ECC_DIGITS - 1 - i);
                        p_native[i] = ((uint64_t)p_digit[0] << 56) | ((uint64_t)p_digit[1] << 48) | ((uint64_t)p_digit[2] << 40) | ((uint64_t)p_digit[3] << 32) |
                            ((uint64_t)p_digit[4] << 24) | ((uint64_t)p_digit[5] << 16) | ((uint64_t)p_digit[6] << 8) | (uint64_t)p_digit[7];
                    }
                }
                
                void ecc_native2bytes(uint8_t p_bytes[ECC_BYTES], const uint64_t p_native[NUM_ECC_DIGITS])
        3600 -> {
                    unsigned i;
                    for(i=0; i<NUM_ECC_DIGITS; ++i)
                    {
                        uint8_t *p_digit = p_bytes + 8 * (NUM_ECC_DIGITS - 1 - i);
                        p_digit[0] = p_native[i] >> 56;
                        p_digit[1] = p_native[i] >> 48;
                        p_digit[2] = p_native[i] >> 40;
                        p_digit[3] = p_native[i] >> 32;
                        p_digit[4] = p_native[i] >> 24;
                        p_digit[5] = p_native[i] >> 16;
                        p_digit[6] = p_native[i] >> 8;
                        p_digit[7] = p_native[i];
                    }
                }
                
                


Top 10 Lines:

     Line      Count

       98   10080640
       70    7294711
       80    5227249
       16     901455
       30     257333
      113     180117
      139       3704
      150       3600
      127       3300
       36       1013

Execution Summary:

       12   Executable lines in this file
       12   Lines executed
   100.00   Percent of the file executed

 23954135   Total number of line executions
1996177.92   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/point/point_add.c:
                #include <stdio.h>
                #include <stdlib.h>
                #include <stdint.h>
                
                #include "curves.h"
                #include "field.h"
                #include "point.h"
                
                
                void EccPoint_add_jacobian(uint64_t *X3, uint64_t *Y3, uint64_t *Z3, uint64_t *X1, 
                                            uint64_t *Y1, uint64_t *Z1, uint64_t *x2, uint64_t *y2)
      270105 -> {
                
                    uint64_t t1[NUM_ECC_DIGITS];
                    uint64_t t2[NUM_ECC_DIGITS];
                    uint64_t t3[NUM_ECC_DIGITS];
                    uint64_t t4[NUM_ECC_DIGITS];
                
                    if(vli_isZero(Z1))
                    {
                        return;
                    }
                
                    // check the infinity
                
                    vli_modSquare_fast(t1, Z1);
                    vli_modMult_fast(t2, t1, Z1);
                    vli_modMult_fast(t1, t1, x2);
                    vli_modMult_fast(t2, t2, y2);
                
                    vli_modSub(t1, t1, X1, curve_p);
                    vli_modSub(t2, t2, Y1, curve_p);
                    if (vli_isZero(t1)) {
                
                        if(vli_isZero(t2)) {
                            uint64_t z[NUM_ECC_DIGITS] = {0};
                            z[0] = 1;
                            EccPoint_double_jacobian(x2, y2, z);
                            vli_set(X3, x2);
                            vli_set(Y3, y2);
                            vli_set(Z3, z);
                
                        } else {
                
                            // return infinity
                
                        }
                
                    }
                    vli_modMult_fast(Z3, Z1, t1);
                
                    vli_modSquare_fast(t3, t1);
                    vli_modMult_fast(t4, t3, t1);
                    vli_modMult_fast(t3, t3, X1);
                    vli_modAdd(t1, t3, t3, curve_p);
                
                    vli_modSquare_fast(X3, t2);
                    vli_modSub(X3, X3, t1, curve_p);
                    vli_modSub(X3, X3, t4, curve_p);
                    vli_modSub(t3, t3, X3, curve_p);
                
                    vli_modMult_fast(t3, t3, t2);
                    vli_modMult_fast(t4, t4, Y1);
                    vli_modSub(Y3, t3, t4, curve_p);
                
                }
                
                
                
                /* Input P = (x1, y1, Z), Q = (x2, y2, Z)
                   Output P' = (x1', y1', Z3), P + Q = (x3, y3, Z3)
                   or P => P', Q => P + Q
                
                    (X,Y)-onlly co-Z addition with update - XYCZ-ADD
                */
                void XYcZ_add(uint64_t *X1, uint64_t *Y1, uint64_t *X2, uint64_t *Y2)
       ##### -> {
                    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
                    uint64_t *t1 = X1, *t2 = Y1, *t3 = X2, *t4 = Y2;
                    uint64_t t5[NUM_ECC_DIGITS];
                    
                    vli_modSub(t5, t3, t1, curve_p); /* t5 = x2 - x1 */
                    vli_modSquare_fast(t5, t5);      /* t5 = (x2 - x1)^2 = A */
                    vli_modMult_fast(t1, t1, t5);    /* t1 = x1*A = B */
                    vli_modMult_fast(t3, t3, t5);    /* t3 = x2*A = C */
                    vli_modSub(t4, t4, t2, curve_p); /* t4 = y2 - y1 */
                    vli_modSquare_fast(t5, t4);      /* t5 = (y2 - y1)^2 = D */
                    
                    vli_modSub(t5, t5, t1, curve_p); /* t5 = D - B */
                    vli_modSub(t5, t5, t3, curve_p); /* t5 = D - B - C = x3 */
                    vli_modSub(t3, t3, t1, curve_p); /* t3 = C - B */
                    vli_modMult_fast(t2, t2, t3);    /* t2 = y1*(C - B) */
                    vli_modSub(t3, t1, t5, curve_p); /* t3 = B - x3 */
                    vli_modMult_fast(t4, t4, t3);    /* t4 = (y2 - y1)*(B - x3) */
                    vli_modSub(t4, t4, t2, curve_p); /* t4 = y3 */
                    
                    vli_set(X2, t5);
                }
                
                /* Input P = (x1, y1, Z), Q = (x2, y2, Z)
                   Output P + Q = (x3, y3, Z3), P - Q = (x3', y3', Z3)
                   or P => P - Q, Q => P + Q
                
                   (X,Y)-only co-A conjugate addition - XYCZ-ADDC
                */
                void XYcZ_addC(uint64_t *X1, uint64_t *Y1, uint64_t *X2, uint64_t *Y2)
       ##### -> {
                    /* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
                    uint64_t t5[NUM_ECC_DIGITS];
                    uint64_t t6[NUM_ECC_DIGITS];
                    uint64_t t7[NUM_ECC_DIGITS];
                    uint64_t *t1, *t2, *t3, *t4;
                    t1 = X1;
                    t2 = Y1;
                    t3 = X2;
                    t4 = Y2;
                    
                    vli_modSub(t5, t3, t1, curve_p); /* t5 = x2 - x1 */
                    vli_modSquare_fast(t5, t5);      /* t5 = (x2 - x1)^2 = A */
                    vli_modMult_fast(t1, t1, t5);    /* t1 = x1*A = B */
                    vli_modMult_fast(t3, t3, t5);    /* t3 = x2*A = C */
                    vli_modAdd(t5, t4, t2, curve_p); /* t4 = y2 + y1 */
                    vli_modSub(t4, t4, t2, curve_p); /* t4 = y2 - y1 */
                
                    vli_modSub(t6, t3, t1, curve_p); /* t6 = C - B */
                    vli_modMult_fast(t2, t2, t6);    /* t2 = y1 * (C - B) */
                    vli_modAdd(t6, t3, t1, curve_p); /* t6 = B + C */
                    vli_modSquare_fast(t3, t4);      /* t3 = (y2 - y1)^2 */
                    vli_modSub(t3, t3, t6, curve_p); /* t3 = x3 */
                    
                    vli_modSub(t7, t1, t3, curve_p); /* t7 = B - x3 */
                    vli_modMult_fast(t4, t4, t7);    /* t4 = (y2 - y1)*(B - x3) */
                    vli_modSub(t4, t4, t2, curve_p); /* t4 = y3 */
                    
                    vli_modSquare_fast(t7, t5);      /* t7 = (y2 + y1)^2 = F */
                    vli_modSub(t7, t7, t6, curve_p); /* t7 = x3' */
                    vli_modSub(t6, t7, t1, curve_p); /* t6 = x3' - B */
                    vli_modMult_fast(t6, t6, t5);    /* t6 = (y2 + y1)*(x3' - B) */
                    vli_modSub(Y1, t6, t2, curve_p); /* t2 = y3' */
                    
                    // vli_set(X2, t3);
                    // vli_set(Y2, t4);
                    vli_set(X1, t7);
                    vli_set(Y1, t6);
                }
                
                


Top 10 Lines:

     Line      Count

       12     270105

Execution Summary:

        3   Executable lines in this file
        3   Lines executed
   100.00   Percent of the file executed

   270105   Total number of line executions
 90035.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/ecc/ecc_encrypt.c:
                /** !
                 * @file ecc_opt.c
                 * @author Wang Ruikai 
                 * @date July 15th, 2019
                 * @brief the point arithmetic operation
                 * */
                
                
                #include <stdio.h>
                #include <stdlib.h>
                #include <stdint.h>
                #include <string.h>
                
                #include "curves.h"
                #include "field.h"
                #include "ecc.h"
                #include "point.h"
                
                #define UMAX(a, b) a>b ? a : b
                #define ERROR(info) fprintf(stderr, "[%s:%d]%s\n    %s", __FILE__, \
                                __LINE__, __func__, info) 
                 
                
                int ecc_encrypt(uint8_t **c, size_t *c_len, 
         100 ->                 uint8_t *m, size_t m_len, uint8_t *key) {
                
                    if(0 != m_len % ECC_CURVE) {
                        ERROR("the length of the message must be a multiple of ECC_CURVE");
                        goto end;
                    }
                
                    /* choose a random k */
                    uint64_t k[NUM_ECC_DIGITS];
                    uint64_t l_tmp[NUM_ECC_DIGITS];
                    uint64_t l_s[NUM_ECC_DIGITS];
                    EccPoint p;
                    EccPoint pk_point;
                    unsigned l_tries = 0;
                    int j;
                    
                    do
                    {
                        if(!getRandomNumber(k) || (l_tries++ >= MAX_TRIES))
                        {
                            ERROR("Can't get a valid random number");
                            goto end;
                        }
                        if(vli_isZero(k))
                        {
                            continue;
                        }
                    
                        if(vli_cmp(curve_n, k) != 1)
                        {
                            vli_sub(k, k, curve_n);
                        }
                    
                        /* pk = k * pk*/
                        /* p = k * G*/
                        ecc_point_decompress(&pk_point, key);        
                
                        EccPoint_mult(&pk_point, &pk_point, k);
                        EccPoint_mult(&p, &curve_G, k);
                    
                    } while(vli_isZero(p.x) || vli_isZero(pk_point.x));
                
                    int digit_cnt = m_len / ECC_CURVE;
                    int i=0;
                
                    uint64_t r[NUM_ECC_DIGITS];
                    uint64_t res[NUM_ECC_DIGITS];
                    uint64_t *l = p.x;
                
                    uint8_t * ret = (uint8_t *)malloc(ECC_CURVE + m_len + 1);
                    /* cipher and the random point */
                
                    ecc_native2bytes(ret+1, p.x);
                    ret[0] = 2 + (p.y[0] & 0x01);
                    
                    /* copy the cipher */ 
                    uint8_t *respt = ret + ECC_CURVE + 1;
                    uint8_t *rpt = m;
                    
                    for(i=1; i<=digit_cnt; ++i) 
                    {
                        
                        ecc_bytes2native(r, rpt);
                        vli_xor(res, l, r);
                        ecc_native2bytes(respt, res);
                        
                        rpt += ECC_CURVE;
                        respt += ECC_CURVE;
                    }
                
                    *c_len = m_len + ECC_CURVE;
                    *c = ret;
                    return 1;
                
                end:
                    free(ret);
                    return 0;
                }
                


Top 10 Lines:

     Line      Count

       25        100

Execution Summary:

        1   Executable lines in this file
        1   Lines executed
   100.00   Percent of the file executed

      100   Total number of line executions
   100.00   Average executions per line


*** File /home/wrk/workspace/easy-ecc/src/test/key.c:
                #include <stdio.h>
                #include <string.h>
                
                #include <curves.h>
                #include <ecc.h>
                #include <point.h>
                #include <field.h>
                
                #define ERROR(info) fprintf(stderr, "[%s:%d]%s\n    %s\n", __FILE__, \
                                __LINE__, __func__, info) 
                
                
                uint8_t p_publicKey[ECC_BYTES+1] = {0}, p_privateKey[ECC_BYTES] = {0};
                uint8_t message[ECC_CURVE] = "hello world";
                size_t m_len = ECC_CURVE;
                uint8_t *c, *dm;
                size_t c_len, dm_len;
                
                int test_multi() 
       ##### -> {
                    uint64_t a[NUM_ECC_DIGITS] = {0}, b[NUM_ECC_DIGITS] = {0};
                    EccPoint p;
                    do
                    {
                        // if(!getRandomNumber(a))
                        // {
                        //     ERROR("Can't get a valid random number");
                        //     goto end;
                        // }
                        // if(!getRandomNumber(b))
                        // {
                        //     ERROR("Can't get a valid random number");
                        //     goto end;
                        // }
                        // if(vli_isZero(a) || vli_isZero(b))
                        // {
                        //     continue;
                        // }
                        int j;
                
                        a[0] = 2; 
                        b[0] = 1;
                    
                        if(vli_cmp(curve_n, a) != 1)
                        {
                
                            vli_sub(a, a, curve_n);
                
                        }
                
                        if(vli_cmp(curve_n, b) != 1)
                        {
                
                            vli_sub(b, b, curve_n);
                
                        }
                    
                        /* pk = k * pk*/
                        /* p = k * G*/
                        EccPoint_mult(&p, &curve_G, a);
                        EccPoint_mult(&p, &p, b);
                
                        EccPoint_mult(&p, &curve_G, b);
                        EccPoint_mult(&p, &p, a);
                
                        vli_modMult_fast(a, a, b);
                
                        EccPoint_mult(&p, &curve_G, a);
                
                    } while(vli_isZero(p.x));
                
                    return 1;
                
                end:
                    return 0;    
                
                }
                
                int test_make_key()
         100 -> {
                    /* code */
                    ecc_make_key(p_publicKey, p_privateKey);
                
                    return 1;
                }
                
                int test_encrypt()
         100 -> {
                
                    if(0 == ecc_encrypt(&c, &c_len, message, m_len, p_publicKey)) {
                
                        ERROR("encrypt error");
                        goto end;
                
                    }
                
                    
                    #ifdef DEBUG
                    {
                        printf("plain message:\n\t");
                        printf("%s\n", message);
                        printf("cipher length: %ld\n", c_len);
                        printf("encrypted cipher:");
                
                        int i;
                        for(i=0; i<c_len; i++) {
                            if(0 == i%16) printf("\n\t");
                            if(0 == i%4) printf(" ");
                            printf("%02x", c[i]);
                        }
                        printf("\n");
                    }
                    #endif
                
                    return 1;
                
                end:
                    return 0;
                
                }
                
                int test_decrypt()
         100 -> {
                
                    if(0 == ecc_decrypt(&dm, &dm_len, c, c_len, p_privateKey)) {
                
                        ERROR("decrypt error");
                        goto end;
                
                    }
                
                    // verify the result 
                    if(dm_len != m_len) 
                    {
                
                        ERROR("the lengths of the message and the decrypted message differ");
                        goto end;
                
                    }
                
                    int i;
                    for(i=0; i<m_len; ++i) {
                
                        if(dm[i] != message[i]) 
                        {
                
                            ERROR("the contents of the message and the decrypted message differ");
                            goto end;
                
                        }
                    
                    }
                
                    #ifdef DEBUG
                    {
                        printf("cipher length: %ld\n", c_len);
                        int i;
                        printf("cipher:");
                        for(i=0; i<c_len; i++) {
                            if(0 == i%16) printf("\n\t");
                            if(0 == i%4) printf(" ");
                            printf("%02x", c[i]);
                        }
                        printf("\n");
                        
                        printf("decrypted message:\n\t");
                        printf("%s\n", dm);
                    }
                    #endif
                 
                    return 1;
                
                end:
                    return 0;
                
                }
                
                
                
                
       ##### -> int main(int argc, char *argv[]) {
                
                    int count;
                    if(1 == argc) {
                        count = 1;
                    }
                
                    else {
                        count = atoi(argv[1]);
                    }
                
                    int i;
                    for(i=0; i<count; i++) {
                        if(0 == test_make_key()) {
                
                            ERROR("error in make_key");
                            goto end;
                
                        }
                
                        if(0 == test_encrypt()) {
                
                            ERROR("error in encrypt");
                            goto end;
                
                        }
                
                        if(0 == test_decrypt()) {
                
                            ERROR("error in decrypt");
                            goto end;
                
                        }
                
                    }
                
                
                
                    return 0;
                end:
                
                    return -1;
                }
                


Top 10 Lines:

     Line      Count

       80        100
       88        100
      123        100

Execution Summary:

        5   Executable lines in this file
        5   Lines executed
   100.00   Percent of the file executed

      300   Total number of line executions
    60.00   Average executions per line
